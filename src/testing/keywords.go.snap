// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`keywords should work 1`] = `

-> import "foo"
 | ^^^^^^ keyword.control.import.go
 |        ^ punctuation.definition.string.begin.go  string.interpreted.go
 |         ^^^ string.interpreted.go
 |            ^ punctuation.definition.string.end.go  string.interpreted.go
-> 
-> if x > max {
 | ^^ keyword.control.if.go
 |    ^ variable.other.go
 |      ^ keyword.operator.comparison.>.go
 |        ^^^ variable.other.go
-> 	x = max
 |  ^ variable.other.go
 |    ^ keyword.operator.assignment.go
 |      ^^^ variable.other.go
-> }
-> 
-> if x := f(); x < y {
 | ^^ keyword.control.if.go
 |    ^ variable.other.go
 |      ^ punctuation.separator.key-value.go
 |       ^ keyword.operator.assignment.go
 |         ^ entity.name.function.go
 |            ^ punctuation.terminator.go
 |              ^ variable.other.go
 |                ^ keyword.operator.comparison.<.go
 |                  ^ variable.other.go
-> 	return x
 |  ^^^^^^ keyword.control.return.go
 |         ^ variable.other.go
-> } else if x > z {
 |   ^^^^ keyword.control.else.go
 |        ^^ keyword.control.if.go
 |           ^ variable.other.go
 |             ^ keyword.operator.comparison.>.go
 |               ^ variable.other.go
-> 	return z
 |  ^^^^^^ keyword.control.return.go
 |         ^ variable.other.go
-> } else {
 |   ^^^^ keyword.control.else.go
-> 	return y
 |  ^^^^^^ keyword.control.return.go
 |         ^ variable.other.go
-> }
-> 
-> switch tag {
 | ^^^^^^ keyword.control.switch.go
 |        ^^^ variable.other.go
-> default: s3()
 | ^^^^^^^ keyword.control.default.go
 |        ^ punctuation.separator.key-value.go
 |          ^^ entity.name.function.go
-> case 0, 1, 2, 3: s1()
 | ^^^^ keyword.control.case.go
 |      ^ constant.numeric.integer.go
 |       ^ punctuation.separator.comma.go
 |         ^ constant.numeric.integer.go
 |          ^ punctuation.separator.comma.go
 |            ^ constant.numeric.integer.go
 |             ^ punctuation.separator.comma.go
 |               ^ constant.numeric.integer.go
 |                ^ punctuation.separator.key-value.go
 |                  ^^ entity.name.function.go
-> case 4, 5, 6, 7: s2()
 | ^^^^ keyword.control.case.go
 |      ^ constant.numeric.integer.go
 |       ^ punctuation.separator.comma.go
 |         ^ constant.numeric.integer.go
 |          ^ punctuation.separator.comma.go
 |            ^ constant.numeric.integer.go
 |             ^ punctuation.separator.comma.go
 |               ^ constant.numeric.integer.go
 |                ^ punctuation.separator.key-value.go
 |                  ^^ entity.name.function.go
-> }
-> 
-> switch x := f(); {
 | ^^^^^^ keyword.control.switch.go
 |        ^ variable.other.go
 |          ^ punctuation.separator.key-value.go
 |           ^ keyword.operator.assignment.go
 |             ^ entity.name.function.go
 |                ^ punctuation.terminator.go
-> case x < 0: return -x
 | ^^^^ keyword.control.case.go
 |      ^ variable.other.go
 |        ^ keyword.operator.comparison.<.go
 |          ^ constant.numeric.integer.go
 |           ^ punctuation.separator.key-value.go
 |             ^^^^^^ keyword.control.return.go
 |                    ^ keyword.operator.arithmetic.-.go
 |                     ^ variable.other.go
-> default: return x
 | ^^^^^^^ keyword.control.default.go
 |        ^ punctuation.separator.key-value.go
 |          ^^^^^^ keyword.control.return.go
 |                 ^ variable.other.go
-> }
-> 
-> switch {
 | ^^^^^^ keyword.control.switch.go
-> case x < y: f1()
 | ^^^^ keyword.control.case.go
 |      ^ variable.other.go
 |        ^ keyword.operator.comparison.<.go
 |          ^ variable.other.go
 |           ^ punctuation.separator.key-value.go
 |             ^^ entity.name.function.go
-> case x < z: f2()
 | ^^^^ keyword.control.case.go
 |      ^ variable.other.go
 |        ^ keyword.operator.comparison.<.go
 |          ^ variable.other.go
 |           ^ punctuation.separator.key-value.go
 |             ^^ entity.name.function.go
-> case x == 4: f3()
 | ^^^^ keyword.control.case.go
 |      ^ variable.other.go
 |        ^^ keyword.operator.comparison.==.go
 |           ^ constant.numeric.integer.go
 |            ^ punctuation.separator.key-value.go
 |              ^^ entity.name.function.go
-> }
-> 
-> for a < b {
 | ^^^ keyword.control.for.go
 |     ^ variable.other.go
 |       ^ keyword.operator.comparison.<.go
 |         ^ variable.other.go
-> 	a *= 2
 |  ^ variable.other.go
 |    ^^ keyword.operator.arithmetic.*=.go
 |       ^ constant.numeric.integer.go
-> }
-> 
-> for i := 0; i < 10; i++ {}
 | ^^^ keyword.control.for.go
 |     ^ variable.other.go
 |       ^ punctuation.separator.key-value.go
 |        ^ keyword.operator.assignment.go
 |          ^ constant.numeric.integer.go
 |           ^ punctuation.terminator.go
 |             ^ variable.other.go
 |               ^ keyword.operator.comparison.<.go
 |                 ^^ constant.numeric.integer.go
 |                   ^ punctuation.terminator.go
 |                     ^ variable.other.go
 |                      ^^ keyword.operator.arithmetic.++.go
-> 
-> for i, _ := range testdata.a {}
 | ^^^ keyword.control.for.go
 |     ^ variable.other.go
 |      ^ punctuation.separator.comma.go
 |        ^ variable.other.go
 |          ^ punctuation.separator.key-value.go
 |           ^ keyword.operator.assignment.go
 |             ^^^^^ keyword.operator.expression.range.go
 |                   ^^^^^^^^ variable.other.go
 |                           ^ punctuation.accessor.go
 |                            ^ variable.field.go
-> 
-> var a [10]string
 | ^^^ storage.type.var.go
 |     ^ variable.other.go
 |       ^ punctuation.brace.square.go
 |        ^^ constant.numeric.integer.go
 |          ^ punctuation.brace.square.go
 |           ^^^^^^ support.type.primitive.go
-> for i, s := range a {}
 | ^^^ keyword.control.for.go
 |     ^ variable.other.go
 |      ^ punctuation.separator.comma.go
 |        ^ variable.other.go
 |          ^ punctuation.separator.key-value.go
 |           ^ keyword.operator.assignment.go
 |             ^^^^^ keyword.operator.expression.range.go
 |                   ^ variable.other.go
-> 
-> var key string
 | ^^^ storage.type.var.go
 |     ^^^ variable.other.go
 |         ^^^^^^ support.type.primitive.go
-> var val interface{}
 | ^^^ storage.type.var.go
 |     ^^^ variable.other.go
 |         ^^^^^^^^^ storage.type.interface.go
-> 
-> m := map[string]int{"foo":0}
 | ^ variable.other.go
 |   ^ punctuation.separator.key-value.go
 |    ^ keyword.operator.assignment.go
 |      ^^^ storage.type.map.go
 |          ^^^^^^ support.type.primitive.go
 |                 ^^^ support.type.primitive.go
 |                     ^ punctuation.definition.string.begin.go  string.interpreted.go
 |                      ^^^ string.interpreted.go
 |                         ^ punctuation.definition.string.end.go  string.interpreted.go
 |                          ^ punctuation.separator.key-value.go
 |                           ^ constant.numeric.integer.go
-> for key, val = range m {
 | ^^^ keyword.control.for.go
 |     ^^^ variable.other.go
 |        ^ punctuation.separator.comma.go
 |          ^^^ variable.other.go
 |              ^ keyword.operator.assignment.go
 |                ^^^^^ keyword.operator.expression.range.go
 |                      ^ variable.other.go
-> 	h(key, val)
 |  ^ entity.name.function.go
 |    ^^^ variable.other.go
 |       ^ punctuation.separator.comma.go
 |         ^^^ variable.other.go
-> }
-> 
-> var ch chan Work = producer()
 | ^^^ storage.type.var.go
 |     ^^ variable.other.go
 |        ^^^^ storage.type.chan.go
 |             ^^^^ entity.name.type.go
 |                  ^ keyword.operator.assignment.go
 |                    ^^^^^^^^ entity.name.function.go
-> for w := range ch {
 | ^^^ keyword.control.for.go
 |     ^ variable.other.go
 |       ^ punctuation.separator.key-value.go
 |        ^ keyword.operator.assignment.go
 |          ^^^^^ keyword.operator.expression.range.go
 |                ^^ variable.other.go
-> 	doWork(w)
 |  ^^^^^^ entity.name.function.go
 |         ^ variable.other.go
-> }
-> 
-> // empty a channel
 | ^^ punctuation.definition.comment.line.go  comment.line.go
 |   ^^^^^^^^^^^^^^^^ comment.line.go
-> for range ch {}
 | ^^^ keyword.control.for.go
 |     ^^^^^ keyword.operator.expression.range.go
 |           ^^ variable.other.go
-> 
-> go Server()
 | ^^ keyword.control.go.go
 |    ^^^^^^ entity.name.function.go
-> go func(ch chan<- bool) { for { sleep(10); ch <- true }} (c)
 | ^^ keyword.control.go.go
 |    ^^^^ storage.type.func.go
 |        ^ punctuation.definition.parameters.begin.go
 |         ^^ variable.other.go
 |            ^^^^ storage.type.chan.go
 |                ^^ keyword.operator.arrow.go
 |                   ^^^^ support.type.primitive.go
 |                       ^ punctuation.definition.parameters.end.go
 |                         ^ punctuation.definition.block.begin.go
 |                           ^^^ keyword.control.for.go
 |                                 ^^^^^ entity.name.function.go
 |                                       ^^ constant.numeric.integer.go
 |                                          ^ punctuation.terminator.go
 |                                            ^^ variable.other.go
 |                                               ^^ keyword.operator.arrow.go
 |                                                  ^^^^ constant.language.boolean.go
 |                                                           ^ variable.other.go
-> 
`;
