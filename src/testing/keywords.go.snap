// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`keywords should work 1`] = `

-> import "foo"
 | ^^^^^^ keyword.control.import.go
 |        ^ punctuation.definition.string.begin.go  string.interpreted.go
 |         ^^^ string.interpreted.go
 |            ^ punctuation.definition.string.end.go  string.interpreted.go
-> 
-> if x > max {
 | ^^ keyword.control.if.go
 |    ^ variable.other.go
 |      ^ keyword.operator.comparison.>.go
 |        ^^^ variable.other.go
 |            ^ punctuation.brace.curly.go
->     x = max
 |     ^ variable.other.go
 |       ^ keyword.operator.assignment.go
 |         ^^^ variable.other.go
-> }
 | ^ punctuation.brace.curly.go
-> 
-> if x := f(); x < y {
 | ^^ keyword.control.if.go
 |    ^ variable.other.go
 |      ^^ keyword.operator.assignment.go
 |         ^ entity.name.function.go
 |          ^ punctuation.brace.round.go
 |           ^ punctuation.brace.round.go
 |            ^ punctuation.terminator.go
 |              ^ variable.other.go
 |                ^ keyword.operator.comparison.<.go
 |                  ^ variable.other.go
 |                    ^ punctuation.brace.curly.go
->     return x
 |     ^^^^^^ keyword.control.return.go
 |            ^ variable.other.go
-> } else if x > z {
 | ^ punctuation.brace.curly.go
 |   ^^^^ keyword.control.else.go
 |        ^^ keyword.control.if.go
 |           ^ variable.other.go
 |             ^ keyword.operator.comparison.>.go
 |               ^ variable.other.go
 |                 ^ punctuation.brace.curly.go
->     return z
 |     ^^^^^^ keyword.control.return.go
 |            ^ variable.other.go
-> } else {
 | ^ punctuation.brace.curly.go
 |   ^^^^ keyword.control.else.go
 |        ^ punctuation.brace.curly.go
->     return y
 |     ^^^^^^ keyword.control.return.go
 |            ^ variable.other.go
-> }
 | ^ punctuation.brace.curly.go
-> 
-> switch tag {
 | ^^^^^^ keyword.control.switch.go
 |        ^^^ variable.other.go
 |            ^ punctuation.brace.curly.go
-> default: s3()
 | ^^^^^^^ keyword.control.default.go
 |        ^ punctuation.separator.key-value.go
 |          ^^ entity.name.function.go
 |            ^ punctuation.brace.round.go
 |             ^ punctuation.brace.round.go
-> case 0, 1, 2, 3: s1()
 | ^^^^ keyword.control.case.go
 |      ^ constant.numeric.integer.go
 |       ^ punctuation.separator.comma.go
 |         ^ constant.numeric.integer.go
 |          ^ punctuation.separator.comma.go
 |            ^ constant.numeric.integer.go
 |             ^ punctuation.separator.comma.go
 |               ^ constant.numeric.integer.go
 |                ^ punctuation.separator.key-value.go
 |                  ^^ entity.name.function.go
 |                    ^ punctuation.brace.round.go
 |                     ^ punctuation.brace.round.go
-> case 4, 5, 6, 7: s2()
 | ^^^^ keyword.control.case.go
 |      ^ constant.numeric.integer.go
 |       ^ punctuation.separator.comma.go
 |         ^ constant.numeric.integer.go
 |          ^ punctuation.separator.comma.go
 |            ^ constant.numeric.integer.go
 |             ^ punctuation.separator.comma.go
 |               ^ constant.numeric.integer.go
 |                ^ punctuation.separator.key-value.go
 |                  ^^ entity.name.function.go
 |                    ^ punctuation.brace.round.go
 |                     ^ punctuation.brace.round.go
-> }
 | ^ punctuation.brace.curly.go
-> 
-> switch x := f(); {
 | ^^^^^^ keyword.control.switch.go
 |        ^ variable.other.go
 |          ^^ keyword.operator.assignment.go
 |             ^ entity.name.function.go
 |              ^ punctuation.brace.round.go
 |               ^ punctuation.brace.round.go
 |                ^ punctuation.terminator.go
 |                  ^ punctuation.brace.curly.go
-> case x < 0: return -x
 | ^^^^ keyword.control.case.go
 |      ^ variable.other.go
 |        ^ keyword.operator.comparison.<.go
 |          ^ constant.numeric.integer.go
 |           ^ punctuation.separator.key-value.go
 |             ^^^^^^ keyword.control.return.go
 |                    ^ keyword.operator.arithmetic.-.go
 |                     ^ variable.other.go
-> default: return x
 | ^^^^^^^ keyword.control.default.go
 |        ^ punctuation.separator.key-value.go
 |          ^^^^^^ keyword.control.return.go
 |                 ^ variable.other.go
-> }
 | ^ punctuation.brace.curly.go
-> 
-> switch {
 | ^^^^^^ keyword.control.switch.go
 |        ^ punctuation.brace.curly.go
-> case x < y: f1()
 | ^^^^ keyword.control.case.go
 |      ^ variable.other.go
 |        ^ keyword.operator.comparison.<.go
 |          ^ variable.field.go
 |           ^ punctuation.separator.key-value.go
 |             ^^ entity.name.function.go
 |               ^ punctuation.brace.round.go
 |                ^ punctuation.brace.round.go
-> case x < z: f2()
 | ^^^^ keyword.control.case.go
 |      ^ variable.other.go
 |        ^ keyword.operator.comparison.<.go
 |          ^ variable.field.go
 |           ^ punctuation.separator.key-value.go
 |             ^^ entity.name.function.go
 |               ^ punctuation.brace.round.go
 |                ^ punctuation.brace.round.go
-> case x == 4: f3()
 | ^^^^ keyword.control.case.go
 |      ^ variable.other.go
 |        ^^ keyword.operator.comparison.==.go
 |           ^ constant.numeric.integer.go
 |            ^ punctuation.separator.key-value.go
 |              ^^ entity.name.function.go
 |                ^ punctuation.brace.round.go
 |                 ^ punctuation.brace.round.go
-> }
 | ^ punctuation.brace.curly.go
-> 
-> for a < b {
 | ^^^ keyword.control.for.go
 |     ^ variable.other.go
 |       ^ keyword.operator.comparison.<.go
 |         ^ variable.other.go
 |           ^ punctuation.brace.curly.go
->     a *= 2
 |     ^ variable.other.go
 |       ^^ keyword.operator.arithmetic.*=.go
 |          ^ constant.numeric.integer.go
-> }
 | ^ punctuation.brace.curly.go
-> 
-> for i := 0; i < 10; i++ {}
 | ^^^ keyword.control.for.go
 |     ^ variable.other.go
 |       ^^ keyword.operator.assignment.go
 |          ^ constant.numeric.integer.go
 |           ^ punctuation.terminator.go
 |             ^ variable.other.go
 |               ^ keyword.operator.comparison.<.go
 |                 ^^ constant.numeric.integer.go
 |                   ^ punctuation.terminator.go
 |                     ^ variable.other.go
 |                      ^^ keyword.operator.arithmetic.++.go
 |                         ^ punctuation.brace.curly.go
 |                          ^ punctuation.brace.curly.go
-> 
-> for i, _ := range testdata.a {}
 | ^^^ keyword.control.for.go
 |     ^ variable.other.go
 |      ^ punctuation.separator.comma.go
 |        ^ variable.other.go
 |          ^^ keyword.operator.assignment.go
 |             ^^^^^ keyword.operator.expression.range.go
 |                   ^^^^^^^^ variable.other.go
 |                           ^ punctuation.accessor.go
 |                            ^ variable.field.go
 |                              ^ punctuation.brace.curly.go
 |                               ^ punctuation.brace.curly.go
-> 
-> var a [10]string
 | ^^^ storage.type.var.go
 |     ^ variable.other.go
 |       ^ punctuation.brace.square.go
 |        ^^ constant.numeric.integer.go
 |          ^ punctuation.brace.square.go
 |           ^^^^^^ support.type.primitive.go
-> for i, s := range a {}
 | ^^^ keyword.control.for.go
 |     ^ variable.other.go
 |      ^ punctuation.separator.comma.go
 |        ^ variable.other.go
 |          ^^ keyword.operator.assignment.go
 |             ^^^^^ keyword.operator.expression.range.go
 |                   ^ variable.other.go
 |                     ^ punctuation.brace.curly.go
 |                      ^ punctuation.brace.curly.go
-> 
-> var key string
 | ^^^ storage.type.var.go
 |     ^^^ variable.other.go
 |         ^^^^^^ support.type.primitive.go
-> var val interface{}
 | ^^^ storage.type.var.go
 |     ^^^ variable.other.go
 |         ^^^^^^^^^ storage.type.interface.go
 |                  ^ punctuation.brace.curly.go
 |                   ^ punctuation.brace.curly.go
-> 
-> m := map[string]int{"foo":0}
 | ^ variable.other.go
 |   ^^ keyword.operator.assignment.go
 |      ^^^ storage.type.map.go
 |         ^ punctuation.brace.square.go
 |          ^^^^^^ support.type.primitive.go
 |                ^ punctuation.brace.square.go
 |                 ^^^ support.type.primitive.go
 |                    ^ punctuation.brace.curly.go
 |                     ^ punctuation.definition.string.begin.go  string.interpreted.go
 |                      ^^^ string.interpreted.go
 |                         ^ punctuation.definition.string.end.go  string.interpreted.go
 |                          ^ punctuation.separator.key-value.go
 |                           ^ constant.numeric.integer.go
 |                            ^ punctuation.brace.curly.go
-> for key, val = range m {
 | ^^^ keyword.control.for.go
 |     ^^^ variable.other.go
 |        ^ punctuation.separator.comma.go
 |          ^^^ variable.other.go
 |              ^ keyword.operator.assignment.go
 |                ^^^^^ keyword.operator.expression.range.go
 |                      ^ variable.other.go
 |                        ^ punctuation.brace.curly.go
->     h(key, val)
 |     ^ entity.name.function.go
 |      ^ punctuation.brace.round.go
 |       ^^^ variable.other.go
 |          ^ punctuation.separator.comma.go
 |            ^^^ variable.other.go
 |               ^ punctuation.brace.round.go
-> }
 | ^ punctuation.brace.curly.go
-> 
-> var ch chan Work = producer()
 | ^^^ storage.type.var.go
 |     ^^ variable.other.go
 |        ^^^^ storage.type.chan.go
 |             ^^^^ entity.name.type.go
 |                  ^ keyword.operator.assignment.go
 |                    ^^^^^^^^ entity.name.function.go
 |                            ^ punctuation.brace.round.go
 |                             ^ punctuation.brace.round.go
-> for w := range ch {
 | ^^^ keyword.control.for.go
 |     ^ variable.other.go
 |       ^^ keyword.operator.assignment.go
 |          ^^^^^ keyword.operator.expression.range.go
 |                ^^ variable.other.go
 |                   ^ punctuation.brace.curly.go
->     doWork(w)
 |     ^^^^^^ entity.name.function.go
 |           ^ punctuation.brace.round.go
 |            ^ variable.other.go
 |             ^ punctuation.brace.round.go
-> }
 | ^ punctuation.brace.curly.go
-> 
-> // empty a channel
 | ^^ punctuation.definition.comment.line.go  comment.line.go
 |   ^^^^^^^^^^^^^^^^ comment.line.go
-> for range ch {}
 | ^^^ keyword.control.for.go
 |     ^^^^^ keyword.operator.expression.range.go
 |           ^^ variable.other.go
 |              ^ punctuation.brace.curly.go
 |               ^ punctuation.brace.curly.go
-> 
-> go Server()
 | ^^ keyword.control.go.go
 |    ^^^^^^ entity.name.function.go
 |          ^ punctuation.brace.round.go
 |           ^ punctuation.brace.round.go
-> go func(ch chan <- bool) { for { sleep(10); ch <- true }} (c)
 | ^^ keyword.control.go.go
 |    ^^^^ storage.type.func.go
 |        ^ punctuation.definition.parameters.begin.go
 |         ^^ variable.other.go
 |            ^^^^ storage.type.chan.go
 |                 ^^ keyword.operator.arrow.go
 |                    ^^^^ support.type.primitive.go
 |                        ^ punctuation.definition.parameters.end.go
 |                          ^ punctuation.definition.block.begin.go
 |                            ^^^ keyword.control.for.go
 |                                ^ punctuation.brace.curly.go
 |                                  ^^^^^ entity.name.function.go
 |                                       ^ punctuation.brace.round.go
 |                                        ^^ constant.numeric.integer.go
 |                                          ^ punctuation.brace.round.go
 |                                           ^ punctuation.terminator.go
 |                                             ^^ variable.other.go
 |                                                ^^ keyword.operator.arrow.go
 |                                                   ^^^^ constant.language.boolean.go
 |                                                        ^ punctuation.brace.curly.go
 |                                                         ^ punctuation.brace.curly.go
 |                                                           ^ punctuation.brace.round.go
 |                                                            ^ variable.other.go
 |                                                             ^ punctuation.brace.round.go
-> 
-> // Select statement
 | ^^ punctuation.definition.comment.line.go  comment.line.go
 |   ^^^^^^^^^^^^^^^^^ comment.line.go
-> var a []int
 | ^^^ storage.type.var.go
 |     ^ variable.other.go
 |       ^ punctuation.brace.square.go
 |        ^ punctuation.brace.square.go
 |         ^^^ support.type.primitive.go
-> var c, c1, c2, c3, c4 chan int
 | ^^^ storage.type.var.go
 |     ^ variable.other.go
 |      ^ punctuation.separator.comma.go
 |        ^^ variable.other.go
 |          ^ punctuation.separator.comma.go
 |            ^^ variable.other.go
 |              ^ punctuation.separator.comma.go
 |                ^^ variable.other.go
 |                  ^ punctuation.separator.comma.go
 |                    ^^ variable.other.go
 |                       ^^^^ storage.type.chan.go
 |                            ^^^ support.type.primitive.go
-> var i1, i2 int
 | ^^^ storage.type.var.go
 |     ^^ variable.other.go
 |       ^ punctuation.separator.comma.go
 |         ^^ variable.other.go
 |            ^^^ support.type.primitive.go
-> select {
 | ^^^^^^ keyword.control.select.go
 |        ^ punctuation.brace.curly.go
-> case i1 = <-c1:
 | ^^^^ keyword.control.case.go
 |      ^^ variable.other.go
 |         ^ keyword.operator.assignment.go
 |           ^^ keyword.operator.arrow.go
 |             ^^ variable.field.go
 |               ^ punctuation.separator.key-value.go
->     print("received ", i1, " from c1\\n")
 |     ^^^^^ entity.name.function.go
 |          ^ punctuation.brace.round.go
 |           ^ punctuation.definition.string.begin.go  string.interpreted.go
 |            ^^^^^^^^^ string.interpreted.go
 |                     ^ punctuation.definition.string.end.go  string.interpreted.go
 |                      ^ punctuation.separator.comma.go
 |                        ^^ variable.other.go
 |                          ^ punctuation.separator.comma.go
 |                            ^ punctuation.definition.string.begin.go  string.interpreted.go
 |                             ^^^^^^^^ string.interpreted.go
 |                                     ^^ constant.character.escape.go  string.interpreted.go
 |                                       ^ punctuation.definition.string.end.go  string.interpreted.go
 |                                        ^ punctuation.brace.round.go
-> case c2 <- i2:
 | ^^^^ keyword.control.case.go
 |      ^^ variable.other.go
 |         ^^ keyword.operator.arrow.go
 |            ^^ variable.field.go
 |              ^ punctuation.separator.key-value.go
->     print("sent ", i2, " to c2\\n")
 |     ^^^^^ entity.name.function.go
 |          ^ punctuation.brace.round.go
 |           ^ punctuation.definition.string.begin.go  string.interpreted.go
 |            ^^^^^ string.interpreted.go
 |                 ^ punctuation.definition.string.end.go  string.interpreted.go
 |                  ^ punctuation.separator.comma.go
 |                    ^^ variable.other.go
 |                      ^ punctuation.separator.comma.go
 |                        ^ punctuation.definition.string.begin.go  string.interpreted.go
 |                         ^^^^^^ string.interpreted.go
 |                               ^^ constant.character.escape.go  string.interpreted.go
 |                                 ^ punctuation.definition.string.end.go  string.interpreted.go
 |                                  ^ punctuation.brace.round.go
-> case i3, ok := (<-c3):  // same as: i3, ok := <-c3
 | ^^^^ keyword.control.case.go
 |      ^^ variable.other.go
 |        ^ punctuation.separator.comma.go
 |          ^^ variable.other.go
 |             ^^ keyword.operator.assignment.go
 |                ^ punctuation.brace.round.go
 |                 ^^ keyword.operator.arrow.go
 |                   ^^ variable.other.go
 |                     ^ punctuation.brace.round.go
 |                      ^ punctuation.separator.key-value.go
 |                         ^^ punctuation.definition.comment.line.go  comment.line.go
 |                           ^^^^^^^^^^^^^^^^^^^^^^^^ comment.line.go
->     if ok {
 |     ^^ keyword.control.if.go
 |        ^^ variable.other.go
 |           ^ punctuation.brace.curly.go
->         print("received ", i3, " from c3\\n")
 |         ^^^^^ entity.name.function.go
 |              ^ punctuation.brace.round.go
 |               ^ punctuation.definition.string.begin.go  string.interpreted.go
 |                ^^^^^^^^^ string.interpreted.go
 |                         ^ punctuation.definition.string.end.go  string.interpreted.go
 |                          ^ punctuation.separator.comma.go
 |                            ^^ variable.other.go
 |                              ^ punctuation.separator.comma.go
 |                                ^ punctuation.definition.string.begin.go  string.interpreted.go
 |                                 ^^^^^^^^ string.interpreted.go
 |                                         ^^ constant.character.escape.go  string.interpreted.go
 |                                           ^ punctuation.definition.string.end.go  string.interpreted.go
 |                                            ^ punctuation.brace.round.go
->     } else {
 |     ^ punctuation.brace.curly.go
 |       ^^^^ keyword.control.else.go
 |            ^ punctuation.brace.curly.go
->         print("c3 is closed\\n")
 |         ^^^^^ entity.name.function.go
 |              ^ punctuation.brace.round.go
 |               ^ punctuation.definition.string.begin.go  string.interpreted.go
 |                ^^^^^^^^^^^^ string.interpreted.go
 |                            ^^ constant.character.escape.go  string.interpreted.go
 |                              ^ punctuation.definition.string.end.go  string.interpreted.go
 |                               ^ punctuation.brace.round.go
->     }
 |     ^ punctuation.brace.curly.go
-> case a[f()] = <-c4:
 | ^^^^ keyword.control.case.go
 |      ^ variable.other.go
 |       ^ punctuation.brace.square.go
 |        ^ entity.name.function.go
 |         ^ punctuation.brace.round.go
 |          ^ punctuation.brace.round.go
 |           ^ punctuation.brace.square.go
 |             ^ keyword.operator.assignment.go
 |               ^^ keyword.operator.arrow.go
 |                 ^^ variable.field.go
 |                   ^ punctuation.separator.key-value.go
->     // same as:
 |     ^^ punctuation.definition.comment.line.go  comment.line.go
 |       ^^^^^^^^^ comment.line.go
->     // case t := <-c4
 |     ^^ punctuation.definition.comment.line.go  comment.line.go
 |       ^^^^^^^^^^^^^^^ comment.line.go
->     //    a[f()] = t
 |     ^^ punctuation.definition.comment.line.go  comment.line.go
 |       ^^^^^^^^^^^^^^ comment.line.go
-> default:
 | ^^^^^^^ keyword.control.default.go
 |        ^ punctuation.separator.key-value.go
->     print("no communication\\n")
 |     ^^^^^ entity.name.function.go
 |          ^ punctuation.brace.round.go
 |           ^ punctuation.definition.string.begin.go  string.interpreted.go
 |            ^^^^^^^^^^^^^^^^ string.interpreted.go
 |                            ^^ constant.character.escape.go  string.interpreted.go
 |                              ^ punctuation.definition.string.end.go  string.interpreted.go
 |                               ^ punctuation.brace.round.go
-> }
 | ^ punctuation.brace.curly.go
-> 
-> for {  // send random sequence of bits to c
 | ^^^ keyword.control.for.go
 |     ^ punctuation.brace.curly.go
 |        ^^ punctuation.definition.comment.line.go  comment.line.go
 |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ comment.line.go
->     select {
 |     ^^^^^^ keyword.control.select.go
 |            ^ punctuation.brace.curly.go
->     case c <- 0:  // note: no statement, no fallthrough, no folding of cases
 |     ^^^^ keyword.control.case.go
 |          ^ variable.other.go
 |            ^^ keyword.operator.arrow.go
 |               ^ constant.numeric.integer.go
 |                ^ punctuation.separator.key-value.go
 |                   ^^ punctuation.definition.comment.line.go  comment.line.go
 |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ comment.line.go
->     case c <- 1:
 |     ^^^^ keyword.control.case.go
 |          ^ variable.other.go
 |            ^^ keyword.operator.arrow.go
 |               ^ constant.numeric.integer.go
 |                ^ punctuation.separator.key-value.go
->     }
 |     ^ punctuation.brace.curly.go
-> }
 | ^ punctuation.brace.curly.go
-> 
-> select {}  // block forever
 | ^^^^^^ keyword.control.select.go
 |        ^ punctuation.brace.curly.go
 |         ^ punctuation.brace.curly.go
 |            ^^ punctuation.definition.comment.line.go  comment.line.go
 |              ^^^^^^^^^^^^^^ comment.line.go
-> 
`;
